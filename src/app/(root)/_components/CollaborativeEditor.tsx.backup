"use client";

import { useEffect, useRef, useState } from 'react';
import { editor } from 'monaco-editor';
import { useUser } from '@clerk/clerk-react';
import { useMutation, useQuery } from 'convex/react';
import { api } from '../../../../convex/_generated/api';
import { nanoid } from 'nanoid';
import { Users, WifiOff, Wifi } from 'lucide-react';

interface CollaborativeEditorProps {
  roomId: string;
  fileId?: Id<"files">;
  language: string;
  initialContent?: string;
  theme: string;
  fontSize: number;
  onContentChange?: (content: string) => void;
}

interface Participant {
  _id: Id<"roomParticipants">;
  userId: string;
  userName: string;
  role: "host" | "collaborator" | "viewer";
  cursorPosition?: {
    line: number;
    column: number;
    fileId?: Id<"files">;
  };
  isActive: boolean;
  lastSeenAt: number;
}

export default function CollaborativeEditor({
  roomId,
  fileId,
  language,
  initialContent,
  theme,
  fontSize,
  onContentChange
}: CollaborativeEditorProps) {
  const { user } = useUser();
  const editorRef = useRef<editor.IStandaloneCodeEditor | null>(null);
  const ydocRef = useRef<Y.Doc | null>(null);
  const providerRef = useRef<WebrtcProvider | null>(null);
  const bindingRef = useRef<MonacoBinding | null>(null);
  
  const [participants, setParticipants] = useState<Participant[]>([]);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting');

  const updatePresence = useMutation(api.collaboration.updatePresence);
  const participantsQuery = useQuery(api.collaboration.getRoomParticipants, { roomId });

  // Update participants when query returns new data
  useEffect(() => {
    if (participantsQuery) {
      setParticipants(participantsQuery);
    }
  }, [participantsQuery]);

  // Initialize Yjs document and WebRTC provider
  useEffect(() => {
    if (!user || !roomId) return;

    console.log(`Initializing collaboration for room: ${roomId}`);

    // Create Yjs document
    const ydoc = new Y.Doc();
    ydocRef.current = ydoc;

    // Create WebRTC provider for real-time sync
    const provider = new WebrtcProvider(roomId, ydoc, {
      signaling: ['wss://signaling.yjs.dev'],
      maxConns: 20,
      filterBcConns: true
    });
    providerRef.current = provider;

    // Set user awareness info
    provider.awareness.setLocalStateField('user', {
      name: user.fullName || user.primaryEmailAddress?.emailAddress || 'Anonymous',
      color: `hsl(${Math.floor(Math.random() * 360)}, 70%, 60%)`,
      userId: user.id,
    });

    // Connection status handlers
    provider.on('status', (event: { connected: boolean }) => {
      console.log('WebRTC connection status:', event.connected);
      setConnectionStatus(event.connected ? 'connected' : 'disconnected');
    });

    provider.on('peers', (peers: { added: string[], removed: string[], webrtcPeers: string[], bcPeers: string[] }) => {
      console.log('Connected peers:', peers.webrtcPeers.length + peers.bcPeers.length);
    });

    // Get the text object for Monaco
    const ytext = ydoc.getText('monaco');
    
    // Wait for provider to sync before setting initial content
    provider.on('synced', ({ synced }: { synced: boolean }) => {
      console.log('Provider sync status:', synced);
      if (synced && ytext.length === 0 && initialContent) {
        console.log('Setting initial content:', initialContent);
        ytext.insert(0, initialContent);
      }
    });

    // Listen for connection status changes
    provider.on('status', ({ connected }: { connected: boolean }) => {
      console.log('WebRTC Provider connected:', connected);
    });

    // Listen for peer connections
    provider.on('peers', ({ webrtcPeers, bcPeers }: { webrtcPeers: unknown[], bcPeers: unknown[] }) => {
      console.log('Connected peers - WebRTC:', webrtcPeers.length, 'BroadcastChannel:', bcPeers.length);
    });

    // Listen for document changes
    ytext.observe(() => {
      if (onContentChange) {
        onContentChange(ytext.toString());
      }
    });

    return () => {
      console.log('Cleaning up collaboration');
      bindingRef.current?.destroy();
      provider.destroy();
      ydoc.destroy();
    };
  }, [user, roomId, initialContent, onContentChange]);

  // Setup Monaco binding when editor is ready
  const handleEditorDidMount = (editor: editor.IStandaloneCodeEditor) => {
    editorRef.current = editor;

    if (ydocRef.current) {
      const ytext = ydocRef.current.getText('monaco');
      
      // Set initial content if Yjs document is empty
      if (ytext.length === 0 && initialContent) {
        console.log('Setting initial content in Monaco mount:', initialContent);
        ytext.insert(0, initialContent);
      }
      
      // Create Monaco binding for collaborative editing
      const model = editor.getModel();
      if (model) {
        console.log('Creating Monaco binding for room:', roomId);
        console.log('Yjs text content length:', ytext.length);
        console.log('Monaco model content length:', model.getValue().length);
        console.log('Provider awareness:', providerRef.current?.awareness);
        
        const binding = new MonacoBinding(
          ytext,
          model,
          new Set([editor]),
          providerRef.current?.awareness
        );
        bindingRef.current = binding;
        console.log('Monaco binding created successfully');
        
        // Force sync after binding
        setTimeout(() => {
          const currentContent = ytext.toString();
          console.log('Current Yjs content after binding:', currentContent.substring(0, 100));
          if (currentContent !== model.getValue()) {
            console.log('Syncing Monaco with Yjs content');
            model.setValue(currentContent);
          }
        }, 100);
      }

      // Track cursor position for presence
      editor.onDidChangeCursorPosition((event) => {
        if (user) {
          const position = event.position;
          updatePresence({
            roomId,
            cursorPosition: {
              line: position.lineNumber,
              column: position.column,
              fileId,
            },
          }).catch(console.error);
        }
      });

      // Update presence periodically
      const presenceInterval = setInterval(() => {
        if (user && editor.hasTextFocus()) {
          const position = editor.getPosition();
          updatePresence({
            roomId,
            cursorPosition: position ? {
              line: position.lineNumber,
              column: position.column,
              fileId,
            } : undefined,
          }).catch(console.error);
        }
      }, 10000); // Update every 10 seconds

      return () => {
        clearInterval(presenceInterval);
      };
    }
  };

  // Get user color for cursors
  const getUserColor = (userId: string) => {
    if (providerRef.current?.awareness) {
      const states = Array.from(providerRef.current.awareness.getStates().values());
      const userState = states.find((state: { user?: { userId: string, color?: string } }) => state.user?.userId === userId);
      return userState?.user?.color || '#888888';
    }
    return '#888888';
  };

  // Connection status indicator
  const getStatusInfo = () => {
    switch (connectionStatus) {
      case 'connected':
        return { icon: Wifi, text: 'Connected', color: 'text-green-400' };
      case 'connecting':
        return { icon: WifiOff, text: 'Connecting...', color: 'text-yellow-400' };
      default:
        return { icon: WifiOff, text: 'Disconnected', color: 'text-red-400' };
    }
  };

  const statusInfo = getStatusInfo();
  const StatusIcon = statusInfo.icon;

  return (
    <div className="h-full flex flex-col">
      {/* Collaboration Header */}
      <div className="flex items-center justify-between px-4 py-2 bg-gray-900/50 border-b border-gray-700/50">
        <div className="flex items-center gap-3">
          <div className={`flex items-center gap-2 ${statusInfo.color}`}>
            <StatusIcon className="w-4 h-4" />
            <span className="text-sm font-medium">{statusInfo.text}</span>
          </div>
          
          <div className="flex items-center gap-2 text-gray-400">
            <Users className="w-4 h-4" />
            <span className="text-sm">{participants.length} online</span>
          </div>
        </div>

        {/* Active participants */}
        <div className="flex items-center gap-1">
          {participants.slice(0, 5).map((participant) => (
            <div
              key={participant._id}
              className="w-8 h-8 rounded-full flex items-center justify-center text-xs font-medium text-white border-2"
              style={{ 
                backgroundColor: getUserColor(participant.userId),
                borderColor: participant.role === 'host' ? '#fbbf24' : 'transparent'
              }}
              title={`${participant.userName} (${participant.role})`}
            >
              {participant.userName.charAt(0).toUpperCase()}
            </div>
          ))}
          {participants.length > 5 && (
            <div className="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center text-xs font-medium text-white">
              +{participants.length - 5}
            </div>
          )}
        </div>
      </div>

      {/* Monaco Editor */}
      <div className="flex-1 relative">
        <Editor
          height="100%"
          language={language}
          theme={theme}
          onMount={handleEditorDidMount}
          options={{
            fontSize,
            minimap: { enabled: false },
            automaticLayout: true,
            scrollBeyondLastLine: false,
            padding: { top: 16, bottom: 16 },
            renderWhitespace: "selection",
            fontFamily: '"Fira Code", "Cascadia Code", Consolas, monospace',
            fontLigatures: true,
            cursorBlinking: "smooth",
            smoothScrolling: true,
            contextmenu: true,
            renderLineHighlight: "all",
            lineHeight: 1.6,
            letterSpacing: 0.5,
            roundedSelection: true,
            scrollbar: {
              verticalScrollbarSize: 8,
              horizontalScrollbarSize: 8,
            },
          }}
        />

        {/* Connection overlay */}
        {connectionStatus === 'connecting' && (
          <div className="absolute inset-0 bg-black/20 flex items-center justify-center">
            <div className="bg-gray-900 p-4 rounded-lg flex items-center gap-3">
              <div className="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full"></div>
              <span className="text-white">Connecting to collaboration session...</span>
            </div>
          </div>
        )}

        {connectionStatus === 'disconnected' && (
          <div className="absolute top-4 left-4 bg-red-900/90 text-red-200 px-3 py-2 rounded-lg text-sm">
            ⚠️ Disconnected from collaboration session
          </div>
        )}
      </div>
    </div>
  );
}